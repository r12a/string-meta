<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<title>Requirements for Language and Direction Metadata in Data Formats</title>
<meta charset="utf-8"/>
<script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
<script class="remove">
      var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:          "ED",
          //publishDate:  		"2018-07-19",
          //previousPublishDate:  "2017-06-24",
          //previousMaturity:  	"WG-NOTE",


          noRecTrack:           true,
          shortName:            "string-meta",
          copyrightStart: 		"2017",
          edDraftURI:   		"https://w3c.github.io/string-meta/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          //authors:  [
          //    { name: "Person", mailto: "someone@example.com",
          //      company: "Invited Expert" },
		  //	     ],
          editors:  [
              { name: "Addison Phillips", mailto: "addison@amazon.com",
                company: "Amazon.com" },
              { name: "Richard Ishida", mailto: "ishida@w3.org",
                company: "W3C" },
			     ],
         

          wg:           "Internationalization Working Group",
          wgURI:         "https://www.w3.org/International/core/",
          wgPublicList: "www-international",
		  bugTracker: { new: "https://github.com/w3c/string-meta/issues", 
		  				open: "https://github.com/w3c/string-meta/issues" } ,
		otherLinks: [
			{
			key: "Github",
			data: [
				{
			  	value: "repository",
			  	href: "https://github.com/w3c/string-meta"
		 		}
				]
			}
			],
		  
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/32113/status",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
      };
    </script>
<link rel="stylesheet" href="local.css" type="text/css" />

</head>

<body>
<div id="abstract">
  <p>This document describes the best practices for identifying language and base direction in data formats used on the Web.</p>
</div>


<div id="sotd">
  <div class="note"> <p style="font-weight: bold; font-size: 
  120%">Sending comments on this document</p> 
  <p>If you wish to make 
  comments regarding this document, please raise them as 
  <a href="https://github.com/w3c/string-meta/issues" style="font-size: 120%;">github issues</a>. 
  Only send comments by email if you are 
  unable to raise issues on github (see links below). All comments are 
  welcome.</p> <p>To make it easier to track comments, please raise 
  separate issues or emails for each comment, and point to the section 
  you are commenting on using a URL for the dated version of the 
  document.</p>
  </div>
</div>

<section>
<h2 id="introduction">Introduction</h2>

<p>This document was developed as a result of observations by the 
Internationalization Working Group over a series of specification 
reviews related to formats based on JSON, WebIDL, and other 
non-markup data languages. Unlike markup formats, such as XML, these 
data languages generally do not provide extensible attributes and were 
not conceived with built-in language or direction metadata.</p>

<p>Natural language information on the Web depends on and benefits from 
the presence of language and direction metadata. Along with support for 
Unicode, mechanisms for including and specifying the base direction and 
the natural language of spans of text are one of the key 
internationalization considerations when developing new formats and 
technologies for the Web.</p>

<p>Markup formats, such as HTML and XML, as well as related styling 
languages, such as CSS and XSL, are reasonably mature and provide 
support for the interchange and presentation of the world's languages 
via built-in features. Data formats need similar mechanisms in order to 
ensure a complete and consistent support for the world's languages and 
cultures.</p>

	


<section id="terminology">
	<h3>Terminology</h3>
	<p>This section defines terminology necessary to understand the contents of this document. The terms defined here are specific to this document.</p>
	
  
  <p>A <dfn data-lt="producer|producers">producer</dfn> is any process where natural language string data is created for later storage, processing, or interchange.</p>
  <p>A <dfn data-lt="consumer|consumers">consumer</dfn> is any process that receives natural language strings, either for display or processing.</p>
  <p>A <dfn data-lt="agreement|agreements|serialization agreement|serialization agreements|serialization">serialization agreement</dfn> (or "agreement" for short) is the common understanding between a producer and consumer about the serialization of string metadata: how it is to be understood, serialized, read, transmitted, removed, etc.</p>
  <p><dfn data-lt="language negotiation">Language negotiation</dfn> is any process which selects or filters content based on language. Usually this implies selecting content in a single language (or falling back to some meaningful default language that is available) by finding the best matching values when several languages or locales [[LTLI]] are present in the content. Some common language negotiation algorithms include the Lookup algorithm in [[BCP47]] or the BestFitMatcher in [[ECMA-402]].</p>
  <p><dfn>LTR</dfn> stands for "left-to-right" and refers to the inline base direction of left-to-right [[!UAX9]]. This is the base text direction used by languages whose starting character progression begins on the left side of the page in horizontal text. It's used for scripts such as Latin, Cyrillic, Devanagari, and many others.</p>
  <p><dfn>RTL</dfn> stands for "right-to-left" and refers to the inline base direction of right-to-left [[!UAX9]]. This is the base text direction used by languages whose starting character progression begins on the right side of the page in horizontal text. It's used for scripts such as Arabic, Hebrew, Syriac, and a few others.</p>
  
  <p class=note>If you are unfamiliar with bidirectional or right-to-left text, there is a basic introduction <a href="https://www.w3.org/International/articles/inline-bidi-markup/uba-basics">here</a>. Additional materials can be found in the Internationalization Working Group's <a href="https://www.w3.org/International/techniques/authoring-html.en?open=direction">Techniques Index</a>.</p>
 </section>
 
 
 
 
 
 <section id="producers_consumers">
  <h3>The String Lifecycle</h3>
  
  <p>It's not possible to consider alternatives for handling string metadata in a vacuum: we need to establish a framework for talking about string handling and data formats.</p>
  
<section id="producers">  
  <h4>Producers</h4>  
  <p>A string can be created in a number of ways, including a content author typing strings into a plain text editor, text message, or editing tool; or a script scraping text from web pages; or acquisition of an existing set of strings from another application or repository. In the data formats under consideration in this document, many strings come from back end data repositories or databases of various kinds. Sources of strings often provide an interface, API, or metadata that includes information about the base direction and language of the data. Some also provide a suitable default for when the direction or language is not provided or specified. In this document, the <b class="newterm">producer</b> of a string is the source, be it human or a mechanism, that creates or provides a string for storage or transmission.</p>
  <p>When a  string is created, it's necessary to (a) detect or capture the appropriate language and base direction to be associated with the string, and (b) take steps, where needed, to set the string up in a way that stores and communicates the language and base direction.</p>
  <p>For example, in the case of a string that is extracted from an HTML form, the base direction can be detected from the computed value of the form's field. Such a value could be inherited from an earlier element, such as the <code class="kw" translate="no">html</code> element, or set using markup or styling on the <code class="kw" translate="no">input</code> element itself. The user could also set the direction of the text by <a href="https://www.w3.org/International/questions/qa-html-dir#userexplicit">using  keyboard shortcut keys</a> to change the direction of the form field. The <code class="kw" translate="no">dirname</code> attribute provides a way of automatically communicating that value with a form submission.</p>
  <p>Similarly, language information in an HTML form  would most likely be inherited from the <code class="kw" translate="no">lang</code> attribute on the <code class="kw" translate="no">html</code> tag, or any element in the tree with a <code class="kw" translate="no">lang</code> attribute.</p>
  <p>If the producer of the string is receiving the string from a location where it was stored by another producer, and where the base direction/language has already been established, the producer needs to understand that the language and base direction has already been set and convert or encode that information for its consumers.</p>
</section>


<section id="consumers">
  <h4>Consumers</h4>
  <p>A <b class="newterm">consumer</b> is an application or process that receives a string for processing and possibly places it into a context where it will be exposed to a user. For display purposes, it must ensure that the base direction and language of the string is correctly applied to the string in that context. For processing purposes, it must at least persist the language and direction and may need to use the language and direction data in order to perform language-specific operations.</p>
  <p>Displaying the string usually involves applying the base direction and language by constructing additional markup, adding control codes, or setting display properties. This indicates to rendering software the base direction or language that should be applied to the string in this display context to get the string to appear correctly. For text direction, it must also isolate embedded strings from the surrounding text to avoid spill-over effects of the bidi algorithm [[UAX9]]. For language, it must make clear the boundaries for the range of text to which the language applies.</p>
  <p>Note that a consumer of one document format might be a <a>producer</a> of another document format.</p>
</section>


<section id="agreements">
  <h4>Serialization Agreements</h4>
  <p>Between any <a>producer</a> and <a>consumer</a>, there needs to be an <a>agreement</a> about what the document format contains and what the data in each field or attribute means. Any time a producer of a string takes special steps to collect and communicate information about the base direction or language of that string, it must do so with the expectation that the consumer of the string will understand how the producer encoded this information. If no action is taken by the producer, the consumer must still decide what rules to follow in order to decide on the appropriate base direction and language, even if it is only to provide some form of default value.</p>
  <p>In some systems or document formats, the necessary behaviour of the producers and consumers of a string are fully specified. In others, such agreements are not available; it is up to users to provide an agreement for how to encode, transmit, and later decode the necessary language or direction informat. Low level specifications, such as JSON, do not provide a string metadata structure by default, so any document formats based on these need to provide the "agreement" themselves.</p>
</section>
</section>

	
<section>
<h3 id="problem_statement">Why is this important?</h3>

<p>Information about the language of content is important when processing 
and presenting natural language data for a variety of reasons. When 
language information is not present, the resulting degradation in appearance or 
functionality can frustrate users, render the content unintelligible, 
or disable important features. Some of the affected processes 
include:</p> 

<ul>
	<li>Selection of fonts and configuration of rendering options to enable the proper display of different languages. This includes 
	prevention of problems such as: <ul>
		<li>"ransom noting" (showing text using multiple different fonts)</li>
		<li>language specific glyph selection,especially the selection of the correct Chinese/Japanese/Korean font due to important presentational variations for the same characters in these languages
		<li>displaying blanks, spaces, question marks, or other disappearance of characters due to the lack of glyphs in the selected font</li> 
	</ul></li>
	<li>Spell checking and other content processing (such as abuse detection, hyphenation, etc.) </li> 
	<li>Indexing, search, and other natural language text operations </li> 
	<li>Filtering according to intended audience and language negotiation </li>
	<li>Selection of a text-to-speech voice and processor, such as used for accessibility or in a voice-based interface</li>
</ul>

<p>Similarly, direction metadata is important to the Web. When a string 
contains text in a script that runs right-to-left (RTL), it must be 
possible to eventually display that string correctly when it reaches an 
end user. For that to happen, it is necessary to establish what <dfn>base 
direction</dfn> needs to be applied to the string as a whole. The 
appropriate base direction cannot always be deduced by simply looking 
at the string; even if it were possible, the producer and consumer of 
the string would need to use the same heuristics to interpret its 
direction.</p>
  
<p>Static content, such as the body of a Web page or the contents of an 
e-book, often has language or direction information provided by the document format 
or as part of the content metadata. Data formats found on the Web 
generally do not supply this metadata. Base specifications such as 
Microformats, WebIDL, JSON, and more, have tended to store natural 
language text in string objects, without additional metadata.</p>

<p>This places a burden on application authors and data format 
designers to provide the metadata on their own initiative. When 
standardized formats do not address the resulting issues, the result 
can be that, while the data arrives intact, its processing or 
presentation cannot be wholly recovered.</p>

<p>In a distributed Web, any <a>consumer</a> can also be a <a>producer</a> for some other process or system. Thus, a given consumer might need to pass language and direction metadata from one document format (and using one <a>agreement</a>) to another consumer using a different document format. Lack of consistency in representing language and direction metadata in serialization agreements poses a threat to interoperability and a barrier to consistent implementation.</p>




<section>
<h4 id="base_example">An Example</h4>

<p>Suppose that you are building a Web page to show a 
customer's library of e-books. The e-books exist in a catalog of data 
and consist of the usual data values. A JSON file for a single entry 
might look something like:</p>

<pre id="example1Data">
{
    "id": "978-977141881-8",
    "title": "&#x0647;&#x0627;&#x0631;&#x064A; &#x0628;&#x0648;&#x062A;&#x0631; &#x0648;&#x062D;&#x062C;&#x0631; &#x0627;&#x0644;&#x0641;&#x064A;&#x0644;&#x0633;&#x0648;&#x0641; (Harry Potter Book 1)",
    "authors": [ "J. K. Rowling" ],
    "language": "ar",
    "pubDate": "2008-01-01",
    "publisher": "مكتبة",
    "coverImage": "https://example.com/images/harrypotter1_cover.jpg",
    // etc.
},
</pre>

<p>Each of the above is a data field in a database somewhere. There is even information about what language the book is in: (<kbd>"language": "ar"</kbd>).</p>

<p>A well-internationalized catalog would include additional metadata 
to what is shown above. That is, for each of the fields containing 
natural language text, such as the <kbd>title</kbd> and 
<kbd>authors</kbd> fields, there should be language  and base 
direction information stored as metadata. (There may be other values as well, such 
as pronunciation metadata for sorting East Asian language information.) 
These metadata values are used by consumers of the data to influence the processing 
and enable the display of the items in a variety of ways. As the JSON data structure 
provides no place to store or exchange these values, it is more difficult
to construct internationalized applications.</p>

<p>One work-around might be to encode the values using a mix of HTML 
and Unicode bidi controls, so that a data value might look like one of 
the following:</p>

<pre>
   "title": "&lt;span lang='ar' dir='rtl'&gt;&#x0647;&#x0627;&#x0631;&#x064A; &#x0628;&#x0648;&#x062A;&#x0631; &#x0648;&#x062D;&#x062C;&#x0631; &#x0627;&#x0644;&#x0641;&#x064A;&#x0644;&#x0633;&#x0648;&#x0641; (Harry Potter Book 1)&lt;/span&gt;"
   "authors": [ "\u200eJ. K. Rowling" ], // contains LRM as first character
</pre>

<p>But JSON is a data interchange format: the content might not end up  with the title field being displayed in an HTML context. The JSON above might very well  be used to populate, say, a local data store which uses native controls  to show the title and these controls will treat the HTML as string contents. Producers and consumers of the data might not expect to introspect the data in order to supply or remove the extra data or to expose it as metadata. Most JSON libraries don't know anything about the structure of the content that they are serializing. Producers want to generate the JSON file directly from a local data store, such as a database. Consumers want to store or retrieve the value for use without additional consideration of the content of each string. In addition, either producers or consumers can have other considerations, such as field length restrictions, that are affected by the insertion of additional controls or markup. Each of these considerations places special burden on implementers to create arbitrary means of serializing, deserializing, managing, and exchanging the necessary metadata, with interoperability as a casualty along the way.</p> 
</section>




<section>
<h4 id="additional_requirements">Additional Requirements for Localization</h4>

<p>The above example shows a data record available in a single language. Some applications might require the ability to send multiple languages for the same field, such as when localizing an application or when multilingual data is available. This is particularly true when the <a>producer</a> needs to support <a>consumers</a> that perform their own <a>language negotiation</a> or when the consumer cannot know which language or languages will be selected for display.</p>

<p><a>Serialization agreements</a> to support this therefore need to represent several different language variations of the same field. For instance, in the example above the values <kbd>title</kbd> or <kbd>description</kbd> might each have translations available for display to users who speak a language other than English. Or an application might have localized strings that the <a>consumer</a> can select at runtime. In some cases, all language variations might be shown to the user. In other cases, the different language values might be matched to user preferences as part of <a>language negotiation</a> to select the most appropriate language to show.</p>

<p>When multiple language representations are possible, a <a>serialization</a> might provide a means (defined in the specification for that document format) for setting a default value for language or direction for the whole of the document. This allows the serialized document to omit language and direction metadata from individual fields in cases where they match the default.</p>
</section>
</section>




<section>
<h3 id="unicode_enough">Isn't Unicode Enough?</h3>

<p>[[!Unicode]] and its character encodings (such as UTF-8) are key elements 
of the Web and its formats. They provide the ability to encode and 
exchange text in any language consistently throughout the Internet. 
However, Unicode by itself does not guarantee perfect presentation and 
processing of natural language text, even though it does guarantee 
perfect interchange.</p>

<p>Several features of Unicode are sometimes suggested as part of the solution to providing language and direction metadata. Specificially, Unicode bidi controls are suggested for handling direction metadata. In addition, there are "tag" characters in the <code>U+E0000</code> block of Unicode originally intended for use as language tags (although this use is now deprecated). </p>

<p>There are a variety of reasons why the addition of characters to 
data in an interchange format is not a good idea. These include:</p>

<ul>
  <li>Most of the data sources used to assemble the documents on the Web will not contain 
  these characters; producers, in the process of assembling or serializing the data, 
  will need to introspect and insert the characters as needed&mdash;changing the data from the original source. Consumers must then deserialize and introspect the information using an identical <a>agreement</a>. The consumer has no way of knowing if the characters found in the data were inserted by the producer (and should be removed) or if the characters were part of the source data. Overzealous producers might introduce additional and unnecessary characters, for example adding an additional layer of bidi control codes to a string that would not otherwise require it. Equally, an overzealous consumer might remove characters that are needed by or intended for downstream processes.</li>
  <li>Another challenge is that many applications that use these data formats have limitations on 
  content, such as length limits or character set restrictions. Inserting additional characters into 
  the data may violate these externally applied requirements, and interfere 
  with processing. In the worst case, portions (or all of) the data value itself might be rejected, corrupted, 
  or lost as a result.</li>
  <li>Inserting additional characters changes the identity of the string. This may have important consequences in certain contexts.</li>
  <li>Inserting and removing characters from the string is not a common operation for most data serialization libraries. Any processing that adds language or direction controls would need to introspect the string to see if these are already present or might need to do other processing to insert or modify the contents of the string as part of serializing the data.</li>
</ul>

<p class=note>This last consideration is important to call out: document formats are often built and serialized using several layers of code. Libraries, such as general purpose JSON libraries, are expected to store and retrieve faithfully the data that they are passed. Higher-level implementations also generally concern themselves with faithful serialization and de-serialization of the values that they are passed. Any process that alters the data itself introduces variability that is undesirable. For example, consider an application's unit test that checks if the string returned from the document is identical to the one in the data catalog used to generate the document. If bidi controls, HTML markup, or Unicode language tags have been inserted, removed, or changed, the strings might not compare as equal, even though they would be expected to be the same.</p>
</section>
</section>





<section>
<h2 id="language_approaches">Best Practices for Communicating Language and Direction</h2>

<p>This section contains the Best Practices as identified by the Internationalization Working Group. [[!RFC2119]] keywords have their usual meaning.</p>

<p class=mustard>Best practices appear with a different background color and decoration like this.</p>

<p>The main issue is how a <a>producer</a> of a string knows how to encode and a <a>consumer</a> of a string will know how to find and interpret the language-related features that ought to be used for that string when it is eventually processed or displayed to the user. This section describes the current best practices, as well as several alternatives that were considered (with reasons for why they are not considered the best practice).</p>   
   
<section>
<h4 id="bcp_metadata">Specifying Metadata in Document Formats</h4>
  
  <p class=note>The TAG and I18N WG are <a href="https://github.com/w3ctag/design-reviews/issues/178">currently discussing</a> what the best practice recommendations should be. This subsection represents our understanding currently.</p>
  
  <p><span class=mustard>Make each natural language string field <a>Localizable</a></span>. For JSON documents, this uses the WebIDL "dictionary" defined below: a pre-built extension that can be used commonly across different document formats using the same base field names and values. </p>
  
<aside class="example">
<p><code><dfn>Localizable</dfn></code> dictionary</p>
<pre class="def idl" data-dfn-for="Localizable" data-link-for="Localizable">
<span class="idlDictionary" data-idl="" data-title="Localizable">dictionary <span class="idlDictionaryID"><code>Localizable</code></a></span> {
	<span class="idlMember" id="idl-def-localizable-lang" data-idl="" data-title="lang" data-dfn-for="localizable"><span class="idlMemberType"><a href="https://www.w3.org/TR/WebIDL-1/#idl-DOMString">DOMString</a></span> <span class="idlMemberName"><a data-lt="lang" href="#dom-localizable-lang" class="internalDFN" data-link-type="dfn" data-for="Localizable"><code>lang</code></a></span>;</span>
    <span class="idlMember" id="idl-def-localizable-dir" data-idl="" data-title="dir" data-dfn-for="localizable"><span class="idlMemberType"><a href="#dom-textdirection" class="internalDFN" data-link-type="dfn"><code>TextDirection</code></a></span> <span class="idlMemberName"><a data-lt="dir" href="#dom-localizable-dir" class="internalDFN" data-link-type="dfn" data-for="Localizable"><code>dir</code></a></span> = <span class="idlMemberValue">"auto"</span>;</span>
};</span>
</pre><dl><dt><dfn data-dfn-for="localizable" data-dfn-type="dfn" id="dom-localizable-lang" data-idl="" data-title="lang">
	
	<code>lang</code></dfn> member</dt>
	<dd>A [[!BCP47]] language tag that specifies the primary language for the values of the human-readable
members of the inheriting dictionary.</dd>
<dt><dfn data-dfn-for="localizable" data-dfn-type="dfn" id="dom-localizable-dir" data-idl="" data-title="dir"><code>
dir</code></dfn> member</dt>
<dd>Specifies the base direction for the human-readable members of an inheriting dictionary.</dd></dl>
<div data-dfn-for="TextDirection" data-link-for="TextDirection" id="textdirection-enum" typeof="bibo:Chapter" resource="#textdirection-enum" property="bibo:hasPart">
	<p id="h-textdirection-enum" resource="#h-textdirection-enum"><dfn data-dfn-for="" data-dfn-type="dfn" id="dom-textdirection" data-idl="" data-title="TextDirection">
       <code>TextDirection</code></dfn> enum</p>
<pre class="def idl">
	<span class="idlEnum" id="idl-def-textdirection" data-idl="" data-title="TextDirection">enum <span class="idlEnumID"><a data-lt="TextDirection" href="#dom-textdirection" class="internalDFN" data-link-type="dfn" data-for=""><code>TextDirection</code></a></span> {    
		<a href="#dom-textdirection-auto" class="idlEnumItem">"auto"</a>,
	    <a href="#dom-textdirection-ltr" class="idlEnumItem">"ltr"</a>,    
	    <a href="#dom-textdirection-rtl" class="idlEnumItem">"rtl"</a>
};</span>
</pre>
<p>The text-direction values are the following, implying that the value of the human-readable members is by default:</p>
<dl><dt><dfn data-dfn-for="textdirection" data-dfn-type="dfn" id="dom-textdirection-auto" data-idl="" data-title="auto">
	<code>auto</code></dfn></dt><dd> Directionality is determined by the Unicode Bidirectional Algorithm [[!UAX9]] algorithm.</dd>
<dt><dfn data-dfn-for="textdirection" data-dfn-type="dfn" id="dom-textdirection-ltr" data-idl="" data-title="ltr">
	<code>ltr</code></dfn></dt><dd>Left-to-right text.</dd>
<dt><dfn data-dfn-for="textdirection" data-dfn-type="dfn" id="dom-textdirection-rtl" data-idl="" data-title="rtl">
	<code>rtl</code></dfn></dt><dd>Right-to-left text.</dd></dl>
</div>
</aside>

<p>By defining the language and direction in a WebIDL dictionary form, specifications can incorporate language and direction metadata for a given String value succinctly. Implementations can recyle the dictionary implementation straightforwardly.</p>

<p>Serialized files utilizing the dictionary and its data values will contain additional fields and can be more difficult to read as a result. Here's an example:</p>

<aside class=example>
	<p>Before:</p>
	<pre>
[
  displayItems: [{
    label: "<span dir="rtl">&#x0627;&#x0644;&#x0628;&#x0646;&#x062F; &#x0627;&#x0644;&#x062E;&#x0627;&#x0635; (&#x0644;&#x0644;&#x0628;&#x064A;&#x0639;!)</span>",
    amount: { },
  }]
]</pre>
	<p>After:</p>
		<pre>
[
  displayItems: [{
    label: {
        value: "<span dir="rtl">&#x0627;&#x0644;&#x0628;&#x0646;&#x062F; &#x0627;&#x0644;&#x062E;&#x0627;&#x0635; (&#x0644;&#x0644;&#x0628;&#x064A;&#x0639;!)</span>",
        lang: "ar-AE",
        dir: "rtl"
    },	
    amount: { },
  }]
]</pre>
</aside>


<p>If an application needs to provide for <a>language negotiation</a> or if the data is available in multiple languages, the <a>Localizable</a> strings can further be organized into arrays with multiple languages for the same value. A simple example might look like this:</p>

<aside class=example>
<pre>
	"title": [ { "value": "Harry Potter", "lang": "en" },
	           { "value": "&#x0647;&#x0627;&#x0631;&#x064A; &#x0628;&#x0648;&#x062A;&#x0631;", "lang": "ar",  "dir": "rtl"}, 
	           { "value": "&#x30CF;&#x30EA;&#x30FC;&#x30DD;&#x30C3;&#x30BF;&#x30FC;", "lang": "ja" },
	           { "value": "哈利波特", "lang": "zh-Hans", "dir": "ltr"} ],
</pre>
</aside>

<p>A common use for multiple language values is to enable <a href="#additionalRequirements">runtime selection of the language</a>. Altering the format above slightly allows for fast selection of the appropriate language from the array of available languages:</p>

<aside class=example>
<pre>
	"title": [ "en": { "value": "Harry Potter", "lang": "en" },
	           "ar": { "value": "&#x0647;&#x0627;&#x0631;&#x064A; &#x0628;&#x0648;&#x062A;&#x0631;", "lang": "ar",  "dir": "rtl"}, 
	           "ja": { "value": "&#x30CF;&#x30EA;&#x30FC;&#x30DD;&#x30C3;&#x30BF;&#x30FC;", "lang": "ja" },
	           "zh-Hans": { "value": "哈利波特", "lang": "zh-Hans", "dir": "ltr"} ],
</pre>
	<p>Notice that this format embeds the <kbd>lang</kbd> field both as a key in the array and inside the enclosed <kbd>Localizable</kbd> so that the selected or preferred value can easily be extracted as a complete JavaScript or JSON object.</p>
	<p>For example, if the language requested were U.S. English (<kbd>en-US</kbd>), this format makes it easier to match and extract the best fitting title object <kbd>{"value": "Harry Potter", "lang": "en"}</kbd>.</p>
</aside>

<p class=mustard>Specifications and document formats MAY provide for a default language and default direction for an overall document.</p>

<p>This might be helpful when performing <a>language negotiation</a> on several levels and there is a desire to use the same default language. It can also be helpful when a document is known to be in a single language or have a single expected base direction and the additional serialization complexity of using <kbd>Localizable</kbd> can thus be avoided.</p>

<p>Interoperability is enhanced when specifications all use the same attribute name for the default language and default base direction. </p>

<p class=mustard>The name <code>@language</code> is RECOMMENDED as the name of the default language value and <code>@dir</code> as the default direction value.</p>

<p>[[!JSON-LD]] defines a <a href=https://json-ld.org/spec/latest/json-ld/#string-internationalization>mechanism</a> for indicating the default language for a given scope or <code>@context</code> in a JSON document. The name <code>@language</code> was chosen for consistency with JSON-LD.</p>

<aside class=example>
	<p>The following example shows the record used in the <a href="baseExample">example</a> with a default language and direction:</p>
<pre>
{
    "@language": "ar",
    "@dir": "rtl",
    "id": "978-977141881-8",
    "title": "&#x0647;&#x0627;&#x0631;&#x064A; &#x0628;&#x0648;&#x062A;&#x0631; &#x0648;&#x062D;&#x062C;&#x0631; &#x0627;&#x0644;&#x0641;&#x064A;&#x0644;&#x0633;&#x0648;&#x0641; (Harry Potter Book 1)",
    "authors": [ "J. K. Rowling" ],
    "language": "ar",
    "pubDate": "2008-01-01",
    "publisher": "مكتبة",
    "coverImage": "https://example.com/images/harrypotter1_cover.jpg",
    // etc.
},
</pre>

<p>Here is the same example without using the default:</p>
<pre>
{
    "id": {"value": "978-977141881-8", "dir": "ltr"},
    "title": {"value": "&#x0647;&#x0627;&#x0631;&#x064A; &#x0628;&#x0648;&#x062A;&#x0631; &#x0648;&#x062D;&#x062C;&#x0631; &#x0627;&#x0644;&#x0641;&#x064A;&#x0644;&#x0633;&#x0648;&#x0641; (Harry Potter Book 1)", 
		"lang": "ar", "dir": "rtl" },
    "authors": [ {"value": "J. K. Rowling", "lang": "en"} ],
    "language": "ar",
    "pubDate": "2008-01-01",
    "publisher": {"value": "&#x0645;&#x0643;&#x062A;&#x0628;&#x0629;", "lang": "ar", "dir": "rtl"},
    "coverImage": "https://example.com/images/harrypotter1_cover.jpg",
    // etc.
},
</pre>
	
<p>Note that a direction value was applied to the ISBN number, so that it isn't rearranged on display in a RTL context. If the consumer is aware of the semantic value of the id, this is not necessary, however, it is useful when the data is shared in a new context where such private arrangements don't hold.</p>
<p>And now the same example again,  using the default, but overriding it where needed:</p>
<pre>
{
    "@language": "en",
    "@dir": "ltr",
    "id": {"978-977141881-8"},
    "title": [ "en": {"value": "Harry Potter", "lang": "en"},
               "ar": {"value": "&#x0647;&#x0627;&#x0631;&#x064A; &#x0628;&#x0648;&#x062A;&#x0631;", "lang": "ar",  "dir": "rtl"} ],
    "authors": [ {"value": "J. K. Rowling", "lang": "en"} ],
    "language": "ar",
    "pubDate": "2008-01-01",
    "publisher": {"value": "&#x0645;&#x0643;&#x062A;&#x0628;&#x0629;", "lang": "en"},
    "coverImage": "https://example.com/images/harrypotter1_cover.jpg",
    // etc.
},
</pre>
	
</aside>
</section>





<section>
<h3 id="controls_in_strings">Bidi Isolation and Isolating Controls in Strings</h3>

<p class=mustard>Do not produce or require bidi isolating controls by default.</p> 
<p>Bidi isolating controls are plain text control characters that can be used to indicate that a span of text should be "isolated" from the surrounding bidirectional context. A frequent question is whether content management systems or document formats should include these characters by default around strings that can appear in multiple contexts. An example of this would be a localizable string table for an application. Since the content author cannot know the bidi context in which the string will be displayed in advance, providing the controls could help insulate the strings from improper display later.</p>

<p>HTML5 [[HTML5]] introduced isolation at the element level by default. This allows for text insertion into an HTML context without the need for isolating controls. However, not all strings appear in an HTML context. Use of strings in a plain text or other display context cannot be guaranteed the isolating behavior provided by HTML.</p>

<p>While some strings can certainly benefit from using isolating bidi controls, consistent usage can produce layers of overhead, processing, and validation that are unnecessary. Use of these controls should be reserved for cases in which the assembly and presentation of the text depends on runtime directional determination. For example, isolating controls can be included around a variable name in a string whose contents will be determined at runtime.</p>

<aside class=example>
	<p>Example of inappropriate use of isolating controls:</p>
	<pre>&amp;#x2066;This string has an LRI/PDI around it.&amp;#x2069;</pre>
	
	<p>Example of appropriate use of isolating controls:</p>
	<pre>Restaurant &amp;#x2068;$name&amp;#x2069; has &amp;#x2068;$numReviews&amp;#x2069; reviews.</pre>
</aside>

<p>The advantages of using isolating controls around a string are that the string can then be inserted into any context (that understands isolating controls) without additional processing.</p>

<p>The disadvantages of using isolating controls around a string are several. For most text the controls are superfluous and contribute to storage and processing overhead. The controls also affect the length of the string. Operations such as string truncation need to keep the controls paired.</p>
</section>
</section>





<section>
<h2 id="use_cases">Requirements and Use Cases</h2>
	
	<p>This section of the document describes in depth the need for language and direction metadata and various use cases helpful in understanding the best practices and alternatives listed above.</p>
	
    
    
<section>
<h3 id="language_identification">Identifying the Language of Content</h3>


<section>
<h4 id="definitions">Definitions</h4>

<p><dfn id="langmeta">Language metadata</dfn> typically indicates the 
intended linguistic audience or user of the resource as a whole, and 
it's possible to imagine that this could, for a multilingual resource, 
involve a property value that is a list of languages. A property that 
is about language metadata may have more than one value, since it aims 
to describe all potential users of the information</p>

<p>The <dfn id="tpl">text-processing language</dfn> is the language of a 
particular range of text (which could be a whole resource or just part 
of it). A property that represents the text-processing language needs 
to have a single value, because it describes the text content in such a 
way that tools such as spell-checkers, default font applicators, 
hyphenation and line breakers, case converters, voice browsers, and 
other language-sensitive applications know which set of rules or 
resources to apply to a specific range of text. Such applications 
generally need an unambiguous statement about the language they are 
working on.</p>
</section>




<section>
<h4 id="lang_use_cases">Language Tagging Use Cases</h4>
  <p>Kensuke is reading an old Tibetan manuscript from the Dunhuang 
	collection. The tool he is using to read the manuscript has access 
	to annotations created by scholars working in the various languages 
	of the International Dunhuang Project, who are commenting on the 
	text. The section of the manuscript he is currently looking at has 
	commentaries by people writing in Chinese, Japanese, and Russian. 
	Each of these commentaries is stored in a separate  annotation, but 
	the annotations point to the same point in the target document. 
	Each commentary is mainly written in the language of the scholar, 
	but may contain excerpts from the manuscript and other sources 
	written in Tibetan as well quoted text in Chinese and English. Some 
	commentaries may contain parallel annotations, each in a different 
	language. For example, there are some with the same text translated 
	into Japanese, Chinese and Tibetan.</p>
	
  <p>Kensuke speaks Japanese, so he generally wants to be presented with the 
    Japanese commentary.</p>
    
    
 <section>
   <h5 id="language_metadata">Capturing the language of the audience</h5>
   <p>The annotations containing the Japanese commentary have a <code class="kw" 
translate="no">language</code> property set to &quot;<code class="kw" 
translate="no">ja</code>&quot; (Japanese). The tool he is using knows that he 
     wants to read Japanese commentaries, and it uses this information to 
     select and present to him the text contained in that body.  This is 
     language information being used as metadata about the intended audience – it indicates to the 
     application doing the retrieval that the intended consumer of the 
    information  wants Japanese.</p>
    
   <p>Some of the annotations contain text in more than one language. 
   For example, there are several with commentary in  Chinese, Japanese 
   and Tibetan. For these annotations, it's appropriate to set the 
   <code class="kw" translate="no">language</code> property to 
   &quot;<code class="kw" translate="no">ja,zh,bo</code>&quot; – 
   indicating that both Japanese and Chinese readers may want to find 
   it.</p> <p>The language tagging that is happening here is likely to 
   be at the resource level, rather than the string level. It's 
   possible, however, that the text-processing language for strings 
   inside the resource may be assumed by looking at the resource level 
   language tag – but only if it is a single language tag. If the tag 
   contains &quot;ja,zh,bo&quot; it's not clear which strings are in 
   Japanese, which are in Chinese, and which are in Tibetan.</p>
 </section>



<section>
<h5 id="text_processing">Capturing the text-processing language</h5>  
  <p>Having identified the relevant annotation text to present to 
    Kensuke, his application has to then display it so that he can read it. 
    It's important to apply the correct font to the text. In the following 
    example, the first line is labeled <code class="kw">ja</code> 
    (<em>Japanese</em>), and the second <code class="kw">zh-Hant</code> (<em>Traditional 
    Chinese</em>) respectively. The characters on both lines are the same code points, but they demonstrate systematic differences between how those and similar codepoints are rendered in Japanese vs. Chinese fonts. It's important to associate the right forms with the right language, otherwise you can make the reader uncomfortable or possibly unhappy.</p>
  
  <p class="cjk-demo"><img src="images/ja_zh_fonts.png" alt="雪, 刃, 直, 令, 垔"></p>
  <!--p class="cjk-demo"> 雪, 刃, 直, 令, 垔 </p>
  <p class="cjk-demo" lang="ja"> 雪, 刃, 直, 令, 垔 </p>
  <p class="cjk-demo" lang="zh-Hans"> 雪, 刃, 直, 令, 垔 </p>
  <p class="cjk-demo" lang="zh-Hant"> 雪, 刃, 直, 令, 垔 </p-->
  
  <p>So, it's important to apply a Japanese font to 
	the Japanese text that Kensuke is reading. There are also 
	language-specific differences in the way text is wrapped at the end 
	of a line. For these reasons we need to identify the actual 
	language of the text to which the font or the wrapping algorithm 
	will be applied.</p>
	
	<p>Another consideration that might apply is the use of 
	text-to-speech. A voice browser will need to know whether to use 
	Japanese or Chinese pronunciations, voices, and dictionaries for the ideographic characters 
	contained in the annotation body text.</p>
	
	<p>Various other text rendering or analysis tools need to know 
	the language of the text they are dealing with. Many different types of text processing depend on information about the language of the content in order to provide the proper processing or results and this goes beyond mere presentation of the text. For example, if Kensuke wanted to search for an annotation, the application might provide a full text search capability. In order to index the words in the annotations, the application would need to split the text according to word boundaries. In Japanese and Chinese, which do not use spaces in-between words, this often involves using dictionaries and heuristics that are language specific.</p>
    
    <p>We also need a way to indicate the change of language to Chinese and 
    Tibetan later in the commentary for some annotations, so that 
    appropriate fonts and wrapping algorithms can be applied there. 
  
  </p>
</section>
</section>

</section>


<section>
<h3 id="bidi_use_case">Identifying the Base Direction of Content</h3>

  <p>In order for a <a>consumer</a> to correctly display bidirectional text, such as those in the following use cases, there must be a way for the consumer to determine the required base direction for each string. It is not enough to rely on the Unicode Bidirectional Algorithm to solve these issues. What is needed is a way to establish the overall directional context in which the string will be displayed (which is what 'base direction' means).</p>
<p>These use cases illustrate situations where a failure to apply the necessary base direction creates a problem.</p>


<section>
<h4 id="bidiCase1">Final punctuation</h4>
<p>This use case consists of a string containing Hebrew text followed by punctuation – in this case an exclamation mark. The characters in this string are shown here in the order in which they are stored in memory.</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;"><code><bdo dir="ltr">&quot;בינלאומי!&quot;</bdo></code></p>
  <p>If the string is dropped into a LTR context, it will display like this, which is incorrect – the exclamation mark is on the wrong side:</p>
  <p lang="he" dir="ltr" style="text-align:center; font-size: 2em;">בינלאומי!</p>
  <p>Dropped into a RTL context, this will be the result, which is correct:</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;">בינלאומי!</p>

<p>The Hebrew characters are reversed by applying the Unicode Bidirectional Algorithm (UBA). However, in a LTR context the UBA cannot make the exclamation mark appear to the left of the Hebrew text, where it belongs, unless the base direction is set to RTL around it.</p>
</section>



  <section>
  <h4 id="bidiCase2">Initial Latin</h4>
<p>In this case the Hebrew word is preceded by some Latin text (here a hashtag). The characters in  the order in which they are stored in memory.</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;"><code>
<bdo dir="ltr">&quot;bidi בינלאומי&quot;</bdo></code></p>
  <p>If the string is dropped into a LTR context, it will display like this, which is incorrect – the word 'bidi' should be to the right:</p>
  <p lang="he" dir="ltr" style="text-align:center; font-size: 2em;">bidi בינלאומי</p>
  <p>Dropped into a RTL context, this will be the result, which is correct:</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;">bidi בינלאומי</p>

<p>The Hebrew characters are reversed by applying the Unicode Bidirectional Algorithm (UBA). However, in a LTR context the UBA cannot make the 'bidi' word appear to the right of the Hebrew text, where it belongs, unless the base direction is set to RTL around it.</p>
<p>This has an additional complication. Often, applications will test the first strong character in the string in order to guess the base direction that needs to be applied. In this case, that heuristic will produce the wrong result.</p>
</section>



  <section>
  <h4 id="bidiCase3">Bidirectional text ordering</h4>
<p>In this case the string contains three words with different directional properties. The characters in the order in which they are stored in memory.</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;"><code><bdo dir="ltr">&quot;one שתיים three&quot;</bdo></code></p>
  <p>If the string is dropped into a LTR context, it will display like this, which is correct:</p>
  <p lang="he" dir="ltr" style="text-align:center; font-size: 2em;">one שתיים three</p>
  <p>Dropped into a RTL context, this will be the result, which is incorrect – the order of the items has changed:</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;">one שתיים three  </p>
<p>This can be much worse when combined with punctuation, or in this case an example of markup in an educational context (inserted into a RTL context). The sequence 'one two three' should just be wrapped in <code class="kw" translate="no">span</code> markup:</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;">&lt;span&gt;one שתיים three&lt;/span&gt;</p>
</section>



  <section>
  <h4 id="bidiCase4">Interpreted HTML</h4>
<p>The characters in this string are shown in the order in which they are stored in memory.</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;"><code>
<bdo dir="ltr">&quot;&lt;span dir='ltr'&gt;one שתיים three&lt;/span&gt;&quot;</bdo></code></p>
<p>This use case is for applications that will parse the string and convert any HTML markup to the DOM. In this case, the text should be rendered correctly in an HTML context because the <code class="kw" translate="no">dir</code> attribute indicates the base direction to be applied within the markup. (It also applies bidi isolation to the text in browsers that fully support bidi markup, avoiding any spill-over effects.) It relies, however, on a system where the consumer expects to receive HTML, and knows how to handle bidi markup.</p>
<p>It also requires the producer to take explicit action to identify the appropriate base direction and set up the required markup to indicate that.</p>
</section>



  <section>
  <h4 id="bidiCase5">Neutral LTR text</h4>
<p>The text in this use case could be a phone number, product catalogue number, mac address, etc.The characters in this string are shown in the order in which they are stored in memory.</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;"><code><bdo dir="ltr">&quot;123 456 789&quot;</bdo></code></p>
  <p>If the string is dropped into a LTR context, it will display like this, which is correct:</p>
  <p lang="he" dir="ltr" style="text-align:center; font-size: 2em;">123 456 789</p>
  <p>Dropped into a RTL context, this will be the result, which is incorrect – the sequencing is wrong, and this may not even be apparent to the reader:</p>
  <p lang="he" dir="rtl" style="text-align:center; font-size: 2em;">123 456 789</p>

<p>When presented to a user, the order of the numbers must remain the same even when the directional context of the surrounding text is RTL. There are no strong directional characters in this string, and the need to preserve a strong LTR base direction is more to do with the type of information in the string than with the content.</p>
</section>
</section>

</section>













<section>
<h2 id="ApproachesConsidered">Approaches Considered</h2>
	
	<p>The above <a href="">Best Practices</a> are based on discussion with TAG, implementation in several W3C Specifications, and the recommendations of the Internationalization Working Group. Other approaches to identifying language in document formats have been used occasionally or have been proposed in the past. Each is described below.</p>
  


<section>
    <h3 id="lang-approach">Identifying the Language of Content</h3>




<section>
    <h4 id="html_content">Require HTML or XML for content</h4>
    
	<p>One proposal from members of the Annotation WG was to require HTML/XML formats for such annotation bodies, and use the <code 
	class="kw" translate="no">lang</code> or <code class="kw" translate="no">xml:lang</code> attributes in markup to denote the 
    language changes. (This approach would also apply to base direction by using HTML's built-in <code>dir</code> attribute; there is no built-in attribute in XML.)</p>
    
    <p class=note>This proposal can be useful for <a>agreements</a> that support the interchange of HTML or XML markup data.</p>
    
    <p>The benefit for content that already uses markup is clear. The content will already provide complete markup necessary for the display and processing of the text or it can be extracted from the source page context. HTML and XML processors already know how to deal with this markup and provide ready validation.</p>
    
    <p>The downside of this approach is that many data values are just strings. As with adding Unicode tags or Unicode bidi controls, the addition of markup to strings alters the original string content. Producers are required to introspect strings and add markup as needed. Consumers must likewise remove any additional markup introduced by the producer.</p>
    
    <p>The addition of markup also requires consumers to guard against the usual problems with markup insertion, such as XSS attacks.</p>
    
  </section>

  
  <section id="langapproach2">
    <h4>Create a new datatype</h4>
    <p>If a new datatype were added to JSON to support natural language strings, then specifications could easily specify that type for use in document formats. Since the format is standardized, <a data-lt="producer">producers</a> and <a data-lt="consumer">consumers</a> would not need to guess about direction or language information when it is encoded. Such a serialization might look like the following:</p>
    
    <pre class=example>
myLocalizedString: "Hello World!"@en^ltr          // language and direction
myLocalizedString_ar: "مرحبا بالعالم!"@ar-EG^rtl  // right-to-left example
myLocalizedString_fr: "Bonjour monde !"@fr        // language only
myLocalizedString_und: "שלום עולם!"^rtl           // direction information only
myLanguageNeutralString: "978-0-123-4567-X"       // language-neutral string</pre>

  <p>The downside of adding a datatype is that JSON is a widely implemented format, including many ad-hoc implementations. Any new serialization form would likely break or cause interoperability problems with these existing implementations. JSON is not designed to be a "versioned" format. Any serialization form used would need to be transparent to existing JSON processors and thus could introduce unwanted data or data corruption to existing fields and formats.</p>
  
  <p>[[JSON-LD]] includes some data structures that are partially helpful. Notably, it defines <a href="https://json-ld.org/spec/latest/json-ld/#string-internationalization">string internationalization</a> in the form of a context-scoped <kbd>@language</kbd> value which can be associated with blocks of JSON or within individual objects. There is no definition of base direction, so this is incomplete. The <kbd>@context</kbd> concept can be used by specifications as a means of indicating the default language metadata where omitted from individual strings.</p>
  
  <p>The concept of <a href="https://json-ld.org/spec/latest/json-ld/#language-indexing">language indexing</a> in JSON-LD is used in the Best Practices in this document as a means for localizing a data value.</p>
  </section>


<section id="unicodeTags">
  <h4>Unicode tag characters</h4> 
  
  <p>Unicode tag characters are strongly deprecated by the Unicode Consortium. These tag characters were intended for use in language tagging within plain text contexts and are often suggested as an alternate means of providing in-band non-markup language tagging. We are unaware of an implementations that use them as language tags.</p>

  <p>Here is how Unicode tags are supposed to work:</p>
  
  <p>A [[!BCP47]] language tag is just one of the potential tags that could be applied using this system, so each language tag begins with a tag identification character, in this case <code>U+E0001</code>. The remainder of the Unicode  block for forming tags mirrors the printable ASCII characters. That is, <code>U+E0020</code> is space (mirroring <code>U+0020</code>), <code>U+E0041</code> is capital A (mirroring <code>U+0041</code>), and so forth. Following the tag identification character, you use each tag character to spell out a [[!BCP47]] language tag  using the upper/lowercase letters, digits, and the hyphen character. Normal language tags, which are composed from ASCII letters, digits and hyphens, can be transmogrified into tags by adding <code>0xE0000</code> to each character's code point. Additional structure, such as a language priority list (see [[RFC4647]]) might be constructed using other characters such as comma or semi-colon, although Unicode does not define or even necessarily permit this.</p>
  
  <p>The end of a tag's scope is signalled by the end of the string, or 
  can be signalled explicitly using the cancel tag character U+E007F, 
  either alone (to cancel all tags) or preceeded by the language tag 
  identification character <code>U+E0001</code> (i.e. the sequence 
  <code>&lt;U+E0001,U+E007F&gt;</code> to end only language tags).</p>
  
    
  <p>Tags therefore have a minimum of three characters, and can 
  easily be 12 or more. Furthermore, these characters are supplementary 
  characters. That is, they are encoded using 4-bytes per character in 
  UTF-8 and they are encoded as a surrogate pair (two 16-bit code 
  units) in UTF-16. Surrogate pairs are needed to encode these characters in string types for languages such as 
  Java and JavaScript that use UTF-16 internally. The use of surrogates makes the strings somewhat opaque. For example, <code>U+E0020</code> is encoded in UTF-16 as <kbd>0xDB40.DC20</kbd> and in UTF-8 as the byte sequence <kbd>0xF3.A0.80.A0</kbd>.</p>
  
  <p>Applications that treat 
	the characters as unknown Unicode characters will display them as 
	tofu (hollow box replacement characters) and may count them towards 
	length limits, etc. So they are only useful when applications or 
	interchange mechanisms are fully aware of them and can remove them 
	or disregard them appropriately. Although the characters are not 
	supposed to be displayed or have any effect on text processing, in 
	practice they can interfere with normal text processes such as 
	truncation. line wrapping, hyphenation, spell-checking and so 
	forth.</p>
    
  <p>By design, [[!BCP47]] language tags are intended to be ASCII 
  case-insensitive. Applications handling Unicode tag characters would 
  have to apply similar case-insensitivity to ensure correct 
  identification of the language. (The Unicode data doesn't specify 
  case conversion pairings for these characters; this complicates the 
  processing and matching of langauge tag values encoded using the tag 
  characters.)</p>
  
  <p>Moreover, language tags need to be formed from valid subtags to 
  conform to [[!BCP47]]. Valid subtags are kept in an IANA registry and 
  new subtags are added regularly, so applications dealing with this 
  kind of tagging would need to always check each subtag against the 
  latest version of the registry.</p>
  
  <p>Another issue with these tag characters is that they do not allow 
  nesting of language tags. For example, if a string contains two 
  languages, such as a quote in French inside an English sentence, 
  Unicode tag characters can only indicate where one language starts. 
  To indicate nested languages, tags would need to be embedded into the 
  text not just prefixed to the front.</p>
  
  <p>Finally, although never implemented, other types of tags could be 
  embedded into a string or document using Unicode tag characters. It 
  is possible for these tags to overlap sections of text tagged with a 
  language tag.</p>
  
  <p>Finally, Unicode has recently "recycled" these characters for use in forming sub-regional flags, such as the flag of Scotland (🏴󠁧), which is made of the sequence:󠁢󠁳󠁣󠁴󠁿   </p>
  <ul>
  <li><span class="codepoint"><span lang="ang">&#x1F3F4;</span> [<span class="uname">U+1F3F4 WAVING BLACK FLAG</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0067;</span> [<span class="uname">U+E0067 TAG LATIN SMALL LETTER G</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0062;</span> [<span class="uname">U+E0062 TAG LATIN SMALL LETTER B</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0073;</span> [<span class="uname">U+E0073 TAG LATIN SMALL LETTER S</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0063;</span> [<span class="uname">U+E0063 TAG LATIN SMALL LETTER C</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0074;</span> [<span class="uname">U+E0074 TAG LATIN SMALL LETTER T</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE007F;</span> [<span class="uname">U+E007F CANCEL TAG</span>]</span></li>
  </ul>
  
  <p class="ednote">The above is a new feature of emoji added in Unicode 10.0 (version 5.0 of UTR#51) in June 2017. Proper display depends on your system's adoption of this version.</p>
  
</section>
</section>









<section>
<h3 id="bidi-approaches">Identifying the Base Direction of Content</h3>
  <p>The fundamental problem is how a <a>consumer</a> of a string will know what base direction should be used for that string when it is eventually displayed to a user. A number of alternatives are considered below. Note that, unlike some of the <a href="otherApproaches">language tagging alternatives</a> considered above, each of these mechansisms for identifying or estimating the base direction have utility in specific applications and are in use in different specifications such as [[HTML5]].</p>


<section id="metadata">
  <h4>Metadata</h4>
  
  <div class="summary">
<p><b class="leadin">Summary</b></p>
<p>Recommended?<br>
yes </p>
<p>Pros:</p>
<ul>
<li>, effective &amp; efficient </li>
<li>doesn’t affect the content of the string </li>
<li>no need to parse the string or know how to interpret it</li>
</ul>
<p>Cons:</p>
<ul>
<li>out-of-band information needs to be associated with and kept with strings</li>
</ul>
<p>To note:</p>
<ul>
<li>best used only where necessary, and rely on first-strong heuristics otherwise </li>
<li>producers need to know when to attach metadata because first-strong doesn’t work </li>
<li>it must be possible to associate metadata with any string, but it may also be useful to additionally set a default for all strings</li>
</ul>
</div>
<p>Using metadata external to the string is the RECOMMENDED best practice for indicating the base direction of text. Passing metadata as separate data value from the string provides a simple, effective and efficient method of communicating the intended base direction without affecting the actual content of the string. This requires that the <a>consumer</a> know how to retrieve and process the meaning of that metadata.</p>
  <p>Metadata not only removes the problem of whether or not, and how, to parse markup in a string to determine the direction, but even in the simplest strings, without markup, it avoids the need to inspect and run heuristics on the string to determine its base direction.</p>
  <p>There needs to be metadata available for each individual string. Alternatively, metadata can be inherited, but some mechanism must be available to override the inherited direction for a particular string which differs in direction from the inherited value.  </p>
  <p>Metadata is probably most effective, however (especially for the original creator of the strings), if it is only passed with a string in those cases where first-strong detection is otherwise going to produce a wrong result. This would mean that consumers of strings should not only recognise the metadata, but should also expect to  rely on first-strong heuristics for strings without metadata. It also means that producers of strings need to recognise situations where directional information is needed and set the metadata.</p>
</section>




<section id="firststrong">
  <h4>First-strong</h4>
  <div class="summary">
<p><b class="leadin">Summary</b></p>
<p>Recommended?<br> 
no
</p>
<p>Pros:</p>
<ul>
<li>where it is reliable, information about direction can be obtained without any changes to the string</li>
</ul>
<p>Cons:</p>
<ul>
<li>the base direction applied is unreliable, because the first strong character is not always indicative of the necessary base direction for the string </li>
<li>any string containing HTML bounded by an element with a dir attribute makes the direction undetectable, since dir isolates </li>
<li>the same goes for strings that begin with RLI, etc and end with PDI </li>
<li>it’s not clear how to establish whether markup at the start of a string should be considered when checking for first-strong characters </li>
<li>consumers need to know the semantics of any markup vocabulary used if embedded markup contains the directional information</li>
</ul>
<p>To note:</p>
<ul>
<li>the consumer must know to check the string for first-strong heuristics </li>
<li>needs to skip characters at start of string without strong directional property, and internal isolated sequences </li>
<li>if no directional character is found in the string, there must be an agreement on the default direction </li>
<li>if a string is bounded by markup (eg. &lt;cite&gt;…&lt;/cite&gt;) the directionality of the characters in the markup must be ignored when checking for the first-strong character if, and only if, the markup is going to be handled as markup by the consumer; if this is, say, just some example code, then the direction of the markup characters counts; it’s not clear how to tell the difference </li>
<li>if a string is bounded by markup with directional information (eg. &lt;cite dir=“rtl”&gt;..&lt;cite&gt;) which indicates the base direction to be used, the directional properties of the characters in the string must be ignored</li>
</ul>
</div>
<p> First-strong detection looks for the first character with a strong Unicode directional property in a string, and sets the base direction to match it. Many developers assume that this provides a robust solution, but first-strong detection alone is not always adequate to communicate base direction.</p>
  <p>Note that, if the <a>producer</a> is relying on the <a>consumer</a> using first-strong character detection to establish the contextual base direction of a string, the consumer needs to be aware that it is supposed to use that approach. Although first-strong detection is outlined in the Unicode Bidirectional Algorithm (UBA) [[!UAX9]], it is not the only possible higher-level protocol mentioned for estimating string direction. For example, Twitter and Facebook currently use different default heuristics for guessing the base direction of text&mdash;neither use just simple first-strong detection, and one uses a completely different method.</p>
  <p>The first-strong detection algorithm needs to skip characters at the start of the string that don't have a strong directional property. It also needs to skip embedded runs of text that are directionally isolated from the text around it, if it is to follow the UBA. Isolation may be achieved by Unicode formatting characters, such as RLI, LRI and FSI, or by using markup in the string if that markup is to be interpreted as actual markup by the consumer. For example, elements with the <code>dir</code> attribute in [[HTML5]] are isolating. An element such as <code>&lt;span dir=&quot;rtl&quot;&gt;</code> and all of the text it contains should be skipped by first-strong.</p>
  <p>If no strong directional character is found in the string, the direction should be assumed to be LTR.</p>
  <p>The principal problem encountered with first-strong detection is that the first strong character is not always representative of the base direction that needs to be applied to that string, such as in <a href="#bidiCase2">use case #2</a> above.</p>
  <p>If a string contains markup that will be parsed by the consumer as markup, there are additional problems. Any such markup at the start of the string must also be skipped when searching for the first strong directional character. If, however, there is angle bracket content that is intended to be an <em>example</em> of markup, rather than actual markup, the markup must not be skipped. It isn't clear how a consumer of the string would know the difference between this case and the previous one.</p>
  <p>If parseable markup in the string contains information about the intended direction of the string, that information should be used rather than relying on first-strong heuristics. This is problematic in a couple of ways: (a) it assumes that the consumer of the string understands the semantics of the markup, which may be ok if there is an agreement between all parties to use, say, HTML markup only, but would be problematic, for example, when dealing with random XML vocabularies, and (b) the consumer must be able to  recognise and handle a situation where only the initial part of the string has markup, ie. the markup applies to an inline span of text rather than the string as a whole.</p>
</section>



<section id="rlm">
  <h4>Augmenting <q>first-strong</q> by inserting RLM/LRM markers</h4> 
  
  <div class="summary">
<p><b class="leadin">Summary</b></p>
<p>Recommended?<br>
no </p>
<p>Pros:</p>
<ul>
<li>it provides a reliable way of indicating base direction, as long as the producer can reliably apply markers </li>
<li>in theory, it should be easier to spot the first-strong character in strings that begin with markup, as long as the correct RLM/LRM is prepended to the string</li>
</ul>
<p>Cons:</p>
<ul>
<li>it is not clear that the producer of a string would always apply RLM/LRM when appropriate; a machine is not able to identify cases where those characters would be needed </li>
<li>this approach changes the identity and content of the string </li>
<li>consumers may need to remove the RLM/LRM marker, but may not be able to determine when that is or is not appropriate, since the string may start with an RLM/LRM character intentionally</li>
</ul>
<p>To note:</p>
<ul>
<li>in theory, it should be easier to spot the first-strong character in strings that begin with markup, as long as the correct RLM/LRM is prepended to the string </li>
<li>applications must ensure that they do not accumulate markers</li>
</ul>
</div>
<p>It is possible for a producer of a string to attach an RLM or LRM 
  character to the beginning of the string when the wrong base 
  direction would otherwise be assumed by a process using a simple first-strong 
  heuristic. </p> 
  
  <p>If the producer is a human, they could theoretically apply one of 
  these characters when creating a string in order to signal the 
  directionality. One problem, especially on mobile devices, is the 
  availability or inconvenience of inputting an RLM/LRM character. In 
  addition, because the characters are invisible and because Unicode 
  bidi is complicated, it can be difficult for the user to know that a 
  bidi control will be necessary.</p> 
  
  <p>However, humans often do create text that will later become 
  strings in environments where the bidi algorithm will need help.  For 
  example, if a person types information into an HTML form and relies 
  on the form's base direction or use of shortcut keys to make the 
  string look correct in the form field, they would not need to add 
  RLM/LRM to make the string 'look correct' for themselves, but 
  outside of that context the string would look incorrect unless an 
  appropriate strong character was added to it. Similarly, strings 
  scraped from a web page that has <code class="kw" 
  translate="no">dir=rtl</code> set in the <code class="kw" 
  translate="no">html</code> element would not normally have or need an 
  RLM/LRM character at the start of the string in HTML.</p> 
  
  <p>This approach is therefore only appropriate for 
  general use if it is acceptable to change the value of the string. 
  </p> 
  
  <p>Apart from changing the identity of the string, adding 
  characters to it may have an effect on things such as string length 
  or pointer positions, which may become problematic.</p> 
  
  <p>When inserting an LRM or RLM character, the consumer still depends on 
  applying a first-strong heuristic to get the proper direction; 
  consumers that don't apply first-strong can get the direction 
  wrong.</p> 
  
  <p>If directional information is contained in markup that will be 
  parsed as such by the consumer (for example, <code class="kw" 
  translate="no">dir=rtl</code> in HTML),  the producer  of the string 
  needs to understand that markup in order to set or not set an RLM/LRM 
  character as appropriate. If the producer always adds RLM/LRM to the 
  start of such strings, the consumer is expected to know that. If the 
  producer relies instead on the markup being understood, the consumer 
  is expected to understand the markup.</p> 
  
  <p>The producer of a string should not automatically apply RLM or LRM 
  to the start of the string, but should test whether it is needed. 
  For example, if there's already an RLM in the text, there is no need to add another. 
  If the context is correctly conveyed by first-strong heuristics, there is no 
  need to add additional characters either. Note, however, that testing 
  whether supplementary directional information of this kind is needed 
  is only possible if the producer has access, and knows that it has 
  access, to the original context of the string. Many document formats are generated from data stored away from the original context. For example, the catalog of books in the <a href="#baseExample">original example</a> above is disconnected from the user inputing the bidirectional text.</p>
</section>





<section id="paired">
  <h4>Paired formatting characters</h4>
  <div class="summary">
<p><b class="leadin">Summary</b></p>
<p>Recommended?<br>
no </p>
<p>Pros:</p>
<ul>
<li>none</li>
</ul>
<p>Cons:</p>
<ul>
<li>isolating formatting characters must be used, but they are not yet well supported by consumers </li>
<li>consumers that use first-strong heuristics, rather than recognising this approach, would fail </li>
<li>Unicode limits for embedding levels may be exceeded</li>
</ul>
</div>
<p>This approach inserts paired Unicode formatting characters at the start and end of a string to indicate the base direction. </p>
  <p>If paired formatting characters are used, they should be isolating, ie. starting with RLI, LRI, FSI, and not with RLE or LRE.</p>
  <p>However, it would not be enough to simply apply the UBA first-strong heuristics to such a string, because the Unicode bidi algorithm is unable to ascertain the base direction for a string that starts with RLI/LRI/FSI and ends with PDI. This is because the algorithm skips over isolated sequences and treats them  as a neutral character. A consumer of the string would have to take special steps, in this case, to uncover the first-strong character.</p>
  <p>This approach is also only appropriate if it is acceptable to change the value of the string. In addition to possible issues such as changed string length or pointer positions, this approach runs the risk of one of the paired characters getting lost, either through handling errors, or through text truncation, etc.</p>
  <p>A  producer and a consumer of a string would need to recognise and handle a situation where a string begins with a paired formatting character but doesn't end with it because the formatting characters only describe a part of the string.</p>
  <p>Unicode specifies a limit to the number of embeddings that are effective, and embeddings could build up over time to exceed that limit.</p>
  <p>Consuming applications would need to recognise and appropriately handle the isolating formatting characters. At the moment such support for RLI/LRI/FSI is not pervasive.</p>



  <p class="issue">Need to describe non-isolating controls here.</p>
</section>



<section id="script_subtag">
  <h4>Script subtags</h4>
<p>This section is currently a first draft and needs review.</p>
  
  <div class="summary">
  <p><b class="leadin">Summary</b></p>
  <p>Recommended?<br>
(provisionally, pending deeper investigation) yes, but only when the metadata approach above is not possible</p>

    <p>Pros:</p>
    <ul>
    <li>no need to change the string</li>
    <li>no need to inspect the string</li>
    <li>reliable</li>
<li>no complications when dealing with markup in strings</li>
    </ul>

    <p>Cons:</p>
    <ul>
    <li>only works where it is possible to associate separate language metadata with each string</li>
    <li>some scripts in archaic usage switched between LTR and RTL according to the preference of the author or the context of the content; the language tag is unable to handle non-default approaches for such strings, but this is expected to be an edge-case</li>
    <li>new script tags may be coined, and these will need to be added to the lists used by consumers</li>
<li>how to indicate that LTR base direction must be applied to a wrapper around some strings</li>
    </ul>

    <p>To note:</p>
    <ul>
    <li>may be more efficient to assume a default, in the absence of a script subtag, and use first-strong heuristics in non-problematic cases</li>
    </ul>
  </div>
  
  <p>The W3C Internationalization Working Group recommends that formats and applications should associate dedicated metadata relating to base text direction with strings wherever possible.  In cases where that is not possible due to legacy constraints, but where language metadata <em>can</em> be associated with each string, it may be possible to use the language metadata as a fallback method of identifying the direction for a string (eg. JSON-LD, RDF, etc).</p>
  <p>Note, however, that this is <em>only</em> appropriate when declaring information about the <em>overall</em> base direction to be associated with a string. We do <em>not</em> recommend generalised use of language data to indicate text direction, especially within strings, since the usage patterns are not interchangeable.</p>
  <p>Note, secondly, that language information must use BCP 47 subtags, and that the tag that carries the information should be the script subtag, not the language subtag. For example, Azeri may be written LTR (with the Latin or Cyrillic scripts) or RTL (with the Arabic script).  Therefore, the subtag <code class="kw" translate="no">az</code> is insufficient to clarify intended direction. A language tag such as <code class="kw" translate="no">az-Arab</code>, however, can generally be relied upon to indicate that the overall base direction should be RTL. </p>
<p>There are many strings which are not language-specific but which absolutely need to be wrapped by a mechanism that explicitly associates them with  a particular base direction for correct consumption. For example, Mac addresses inserted into a RTL context need to be displayed with a LTR overall base direction and isolation from the surrounding text. It's not clear how to distinguish these cases from others (in a way that would be feasible when using direction metadata).</p>
  <p>The expected way in which this information is used is as follows. It may be reasonable to assume a default of LTR for all strings unless marked with a script subtag that indicates RTL.  Any string that needs to have an overall base direction of RTL should be labelled for language by the producer using a script subtag. If a script subtag is associated with a string, the consumer would check the script against a list of script subtags that indicate a RTL base direction, and if found would take appropriate action.</p>
  <p>The list of script subtags may be added to in future. In that case, any subtags that indicate a default RTL direction need to be added to the lists used by the consumers of the strings.</p>
  <p>It is perhaps possible to limit the use of script subtag metadata to situations where first-strong heuristics are expected to fail - provided that such cases can be identified, and appropriate action taken by the producer (not always reliable). Consumers would then need to use first-strong heuristics in the absence of a script subtag in order to identify the appropriate base direction. The use of script subtags should not, however, be restricted to strings that need to indicate direction; it is perfectly valid to associate a script subtag with any string.</p>
  <p>This approach avoids the issues associated with first-strong detection when the first-strong character is not indicative of the necessary base direction for the string, and avoids issues relating to the interpretation of markup.</p>
<p>Note that a string that begins with markup that sets a language for the string text content (eg. <code translate="no">&lt;cite lang=“en-Latn”&gt;</code>) is not problematic here, since that language declaration is not expected to play into the setting of the base direction.</p>
<p>There are some rare situations where the base direction can not necessarily be identified from the script subtag, but these are really limited to archaic usage of text.  For example, Japanese and Chinese text prior to World War 2 was often written RTL, rather than LTR. Languages such as those written using Egyptian Hieroglyphs, or the Tifinagh Berber script, could formerly be written either LTR or RTL, however the default for scholastic research tends to LTR.</p>
</section>
</section>
</section>


<section class="appendix" id="Acknowledgements">
<h2>Acknowledgements</h2>

<!-- Order new entries by family name -->
<p>The Internationalization (I18N) Working Group would like to thank 
the following contributors to this document: 
    Mati Allouche, 
    David Baron,
    Tobie Langel,
    Sangwhan Moon,
    Felix Sasaki, 
    Najib Tounsi, 
    
 and many others.</p>

<p>The following pages formed the initial basis of this document:</p>
<ul>
  <li><a href="https://w3c.github.io/i18n-discuss/notes/annotation-language-use-cases.html">Use cases for language information in web annotations</a></li>
  <li><a href="http://w3c.github.io/i18n-discuss/notes/string-base-direction.html">Support for bidi text in strings</a></li>
  <li><a href="http://w3c.github.io/i18n-discuss/notes/json-bidi.html">Notes on JSON strings and text direction</a></li>
</ul>

</section>


</body>
</html>
